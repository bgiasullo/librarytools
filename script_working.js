// Keep only subject_ids and annotations columns
function filterColumns(rows) {
  return rows.map(r => ({
    subject_ids: r.subject_ids,
    annotations: r.annotations
  }));
}

// Unwanted text blocks
const removeBlocks = [
  `[{"task":"T4","value":"`,
  `","taskType":"textFromSubject"},{"task":"T1","task_type":"dropdown-simple","value":{"select_label":"Main Dropdown","option":true,"value":1,"label":"Page is blank"}}]`,
  `","taskType":"textFromSubject"},{"task":"T1","task_type":"dropdown-simple","value":{"select_label":"Main Dropdown","option":true,"value":0,"label":"Corrections made"}}]`,
  `","taskType":"textFromSubject"},{"task":"T1","task_type":"dropdown-simple","value":{"select_label":"Main Dropdown","option":true,"value":2,"label":"No corrections needed"}}]`,
  `","taskType":"textFromSubject"},{"task":"T1","task_type":"dropdown-simple","value":{"select_label":"Main Dropdown","option":true,"value":3,"label":"Text is illegible"}}]`
];

// Replace unicode + known symbols
function applyReplacements(text) {
  if (!text) return text;
  return text
    .replace(/\\u0026/g, "&")
    .replace(/\\u003e/g, ">")
    .replace(/\\u003c/g, "<")
    .replace(/♂/g, "[male]")
    .replace(/♀/g, "[female]")
    .replace(/⚥/g, "[intersex]")
    .replace(/\\"/g, '"')
    .replace(/\\n/g, "\n");
}

// Remove blocks
function removeSpecifiedText(text) {
  if (!text) return text;
  let cleaned = text;
  removeBlocks.forEach(b => cleaned = cleaned.split(b).join(""));
  return cleaned;
}

// ----- TEXT SIMILARITY -----
function tokenize(str) {
  return str.toLowerCase().replace(/[^a-z0-9]+/g, " ").trim().split(/\s+/);
}

function termFreqMap(str) {
  const freq = {};
  tokenize(str).forEach(w => freq[w] = (freq[w] || 0) + 1);
  return freq;
}

function vecDot(a, b) {
  return Object.keys(a).reduce((sum, k) => sum + (b[k] ? a[k] * b[k] : 0), 0);
}

function cosineSimilarity(a, b) {
  const A = termFreqMap(a);
  const B = termFreqMap(b);
  const dot = vecDot(A, B);
  const magA = Math.sqrt(vecDot(A, A));
  const magB = Math.sqrt(vecDot(B, B));
  return (!magA || !magB) ? 0 : dot / (magA * magB);
}

// ----- MAIN PROCESS -----
function processCSV() {
  const file = document.getElementById("csvfile").files[0];
  const status = document.getElementById("status");

  if (!file) {
    status.textContent = "Please upload a CSV file.";
    return;
  }

  status.textContent = "Reading CSV...";

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    complete: function(results) {

      // Keep needed columns
      let rows = filterColumns(results.data);

      status.textContent = "Cleaning text...";

      rows = rows.map(row => {
        let txt = row.annotations;
        txt = removeSpecifiedText(txt);
        txt = applyReplacements(txt);

        // Add footer at TOP (no leading newline)
        txt = `[This text was generated by AI then edited by volunteers. The text contains errors.]\n\n` + txt;

        return { ...row, annotations: txt };
      });

      status.textContent = "Comparing annotations...";

      // Group by subject_ids
      const groups = {};
      rows.forEach(r => {
        if (!groups[r.subject_ids]) groups[r.subject_ids] = [];
        groups[r.subject_ids].push(r.annotations);
      });

      const finalRows = [];

      for (const id in groups) {
        const ann = groups[id];

        if (ann.length === 1) {
          finalRows.push({ subject_ids: id, annotations: ann[0] });
          continue;
        }

        let bestA = null, bestB = null, best = -1;

        for (let i = 0; i < ann.length; i++) {
          for (let j = i + 1; j < ann.length; j++) {
            const sim = cosineSimilarity(ann[i], ann[j]);
            if (sim > best) {
              best = sim;
              bestA = ann[i];
              bestB = ann[j];
            }
          }
        }

        const chosen = Math.random() < 0.5 ? bestA : bestB;

        finalRows.push({
          subject_ids: id,
          annotations: chosen
        });
      }

      status.textContent = "Preparing download...";

      const outCSV = Papa.unparse(finalRows);
      const blob = new Blob([outCSV], { type: "text/csv" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "cleaned-zooniverse-data.csv";
      a.click();

      URL.revokeObjectURL(url);
      status.textContent = "Done! Your cleaned CSV has downloaded.";
    }
  });
}
